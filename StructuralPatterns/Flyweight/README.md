## FlyWeight Design Pattern

## [Implementation](./Implementation/additionOperation.cs) And [How To Use](./UseFlyWeight.cs)

### a little advanced sample [here](https://github.com/MrAliSalehi/MethodCacher).

### **`GOF:`**

#### Flyweight AKA: **Cache**

به اشتراک گذاشتن منابع و state های مختلف بین چندین ابجکت بجای ذخیره سازی برای هر ابجکت به صورت جداگانه.


### **`Concept:`**

این پترن بیشتر به عنوان یک optimization به حساب میاد چون مشگلی که این پترن سعی در حال آن دارد ,محدود بودن منابع سیستم مثل مموری هست.



> اگر اپلیکیشن شما همچین مشگلی ندارد سعی نکنید این پترن رو پیاده کنید
> > صرفا پیچیدگی های بیشتر به کد اضافه میکنید و فایده ای هم براتون نخواهد داشت.

نحوه کار این پترن هم به این صورت هست که ابجکت هایی که مشترک هستند و از قبل ساخته شدند,cache شده و مجدد استفاده میشند

برای پیاده سازی این پترن باید به state های ابجکت توجه کنید,دو حالت مختلف رو درنظر بگیرید:

>- **Intrinsic (internal):**
>
> حالات داخلی ابجکت که نمیتواند تعفیر کند و درواقع immutable هستند

> - **Extrinsic (external):**
>
> حالاتی که متفیر,مربوط به context خاص و از بیرونِ ابجکت به آن اعمال میشود.

بعد از اینکه state های ابجکت را شناسایی کردید ,میتوانید حالت های extrisinc رو کش کنید.

##

**تصور کنید:**

یک ماشین حساب دارید که ۲ عدد ورودی گرفته و یک کلاس که حاوی جواب است بر میگرداند,حالا تصور کنید ۳۰ عملیات با این ماشین حساب انجام دهید ,۳۰ ابجکت جدید به همراه محتویاتش رو توی مموری ول کردید تا GC عزیز تمیزش کند.

**شاید فکر کنید که ۳۰ ابجکت در مموری مسعله چندان مهمی نیست**

درست فکر میکنید,اگر مشگلتون فقط ۳۰ ابجکت هستش بیخیال بشید و برنامتون رو پیچیده تر نکنید.

اما تصور کنید اگر قرار بود همین ۳۰ ابجکت , ۳۰ میلیون ابجکت باشد.اون وقت چطور؟

*(البته درسته که لازم نیست خروجی یک ماشین حساب بجای عدد یک ابجکت باشه ,صرفا یک مثال بود.)*

# FAQ
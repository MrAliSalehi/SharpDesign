## Adapter Design Pattern

## [Implementation](./Implementation/RectAdapter.cs) And [How To Use](./UseAdapter.cs)


### **`GOF:`**
تبدیل اینترفیس به یک اینترفیسه جدیدی که کلاینت انتظار دارد

(client = استفاده کننده از این پترن یا سیستم)

با این پترن کلاس های که بخاطر اینترفیس های ناسازگار نمیتوانستند در کنار هم کار کنند حالا میتوانند در کنار هم باشند




### **`Concept:`**

اگر کتابخانه ای دارید که با یک اینترفیس به خصوص و دیتای خاص کار میکند

ولی نمیتوانید بدون ترکوندنه کد های فعلیتون از اون کتابخونه استفاده کنید

این پترن مشگل را حل میکند 

**تصور کنید:**

یک کتابخانه تبدیل دیتا به مدل های سه بعدی دارید

دیتایی که شما دارید به فرمت تکست هست ولی کتابخانه فقط جیسان قبول میکنه 

خب شاید اگه دسترسی به سورس کتابخانه داشته باشید بتونید با تکست سازگارش کنید

یا کد های فعلیتون رو عوض کنید

که ممکنه کار خطرناکی باشه

توی این سناریو میتونید از یک اداپتور استفاده کنید

##

*Adapter,This is a special object that converts the interface of one object so that another object can understand it*


این کلاس یک ابجکت رو بسته بندی میکند تا پیچیدگی های تبدیل های پشت صحنه را مخفی کند

(Conversions/تبدیل/convert)




> **OCP:** میتونید بدون تعقیر کد فعلیتون اداپتور ها و اینترفیس های جدید به کدبیستون اضافه کنید

> **SRP:** میتونید بخشی از اینترفیس ها و کد هارو از منطق اصلی جدا کنید.

> **typical complexity increases:** مقداری زیادی کد پیچیده به برنامه اضافه میکنید.
> بعضی وقتا کار ساده تر اینه که قسمت ناسازگار کد رو جوری تعقیر بدید که با بقیه کد سازگار بشه. همیشه نیازی به اداپتور ندارید.

# FAQ 

### **> `Object Adapter` OR `Class Adapter`?**

:جواب این سوال به یک مسعله عمیق تر برمیگرده

**Composition or inheritance?**

خب طبعیتا میدونید این دوتا چی هستن

> *inheritance:*
> 
(ارث بری)

کلاس فرزند از کلاس پدر ,تمام رفتار هارو به ارث میبره.

یعنی تعریف یک کلاس بر اساس موجودیت و چیزی که هست.

(IT IS .. )

`Class` **Peykan** `Is a` **Car**.


به حساب میاد oo ارث بری یک حالت سخت تر و محدود تر از 

به طوری که یک تعقیر کوچیک توی اینترفیس های پدر میتونه کله کدبیس اتون رو تحت تاثیر قرار بده.




> *Composition:*

(combine/ترکیب کردن)

ترکیب کردن چند ابجکت و دیتا تایپ جهت ساخت یک ابجکت پیچیده تر.

کاملا برعکس ارث بری عمل میکنه به اینصورت که میتونید از ترکیب چند تایپ و کلاس و اینترفیس مختلف استفاده کنید.

تعریف یک کلاس بر اساس کاری که میکنه.

(what is DOES...)

`Class` **Pekyan** `Has a` **Door.**

این روش طبیعتا دست باز تری بهتون میده و میتونید کار های بیشتری انجام بدید

##
[**برگردیم به سوال اصلی**](#-object-adapter-or-class-adapter)

**Class Adapter**

نوع کلاس,از ارث بری استفاده میکنه.
درنتیجه فقط میتونید از کلاس ها استفاده کنید

(Wrap)

و خبری از اینترفیس نیست,چون طبق تعریف باید حتما از یک بیس و پایه ارث بری کنید

###
**Object Adapter**

این نوع از ترکیب کردن استفاده میکنه,پس درنتیجه شما دست باز تری دارید

و میتونید یا از اینترفیس یا کلاس و یا هر دو استفاده کنید.

نگه داری این کد به طبع راحت تر هستش و خیلی انعطاف پذیر تر از ارث بری عمل میکنه


##

### **>کد کلاینت باید دانشی راجب وجود اداپتور داشته باشه؟**

به طور خلاصه, نه,این کله نکته استفاده از اداپتور ها هست

کد کلاینت و مشتریه اداپتور نیازی به دونستن این نداره که ایا از یک اداپتور داره استفاده میکنه یا نه.


### > سختی ها و مشکلات استفاده از این پترن ؟

در کل استفاده از این پترن سختی خاصی به همراه نداره , ممکنه وصل کردن دو اینترفیس ناسازگار باهم مقداری زمان بر باشه
و صد البته نیازمند نوشتن کد بیشتری هم هست.

اما در عوض سیستم های قدیمی که قابل تعقیر نیستند قابل استفاده میشند و نگه داریشون هم تا حدودی راحت تر میشه.
